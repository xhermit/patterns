
命令模式本质是对命令的封装，从而把发出命令的责任和执行命令的责任分割开了，委派给不同的对象。

 

将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

 看下命令模式是有哪些角色来组成的吧。             

 

1)        命令角色（Command）：声明执行操作的接口。有java接口或者抽象类来实现。

 

2)        具体命令角色（Concrete Command）：将一个接收者对象绑定于一个动作；调用接收者相应的操作，以实现命令角色声明的执行操作的接口。

 

3)        客户角色（Client）：创建一个具体命令对象（并可以设定它的接收者）。

 

4)        请求者角色（Invoker）：调用命令对象执行这个请求。

 

5)        接收者角色（Receiver）：知道如何实施与执行一个请求相关的操作。任何类都可能作为一个接收者。

 
 

Command模式的几个要点：
      1、Command模式的根本目的在于将“行为请求者”与“行为实现者”解耦，在面向对象语言中，常见的实现手段是“将行为抽象为对象”。
      2、实现Command接口的具体命令对象ConcreteCommand 有时候根据需要可能会保存一些额外的状态信息。
      3、通过使用Composite模式，可以将多个“命名”封装为一个“复合命令”MacroCommand。

 

优点：
      1、很容易构造一个命令队列
      2、记录相关的命令日志
      3、增加命令的状态，实现命令的撤销和重做
      4、允许接受请求的一方决定是否可做
      5、新的命令轻而易举可以加入其中

      6、支持宏命令

 

缺点：
      可能会有过多的具体命令类存在



在Struts中Action控制类是整个框架的核心，它连接着页面请求和后台业务逻辑处理。按照框架设计，
  每一个继承自Action的子类，都实现execute方法——调用后台真正处理业务的对象来完成任务。
   RequestProcessor ===> action.execute()


===参考资料=====

http://www.blogjava.net/supercrsky/articles/200497.html
http://chenjumin.iteye.com/blog/627614